/*
 * This source file was generated by the Gradle 'init' task
 */
package edu.harvard.logic;

import org.junit.jupiter.api.Test;

import edu.harvard.App;
import edu.harvard.ChatServiceGrpc;
import edu.harvard.ReplicationServiceGrpc;
import edu.harvard.Chat.ListAccountsRequest;
import edu.harvard.Chat.ListAccountsResponse;
import edu.harvard.Chat.LoginCreateRequest;
import edu.harvard.Chat.LoginCreateResponse;
import edu.harvard.ChatServiceGrpc.ChatServiceBlockingStub;
import edu.harvard.Logreplay.LogMessage;
import edu.harvard.Logreplay.RelayResponse;
import edu.harvard.ReplicationServiceGrpc.ReplicationServiceBlockingStub;
import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;

import static org.junit.jupiter.api.Assertions.*;

import java.io.IOException;

class IntegrationTest {
    static final int PORT = 58585;

    @Test
    void appExists() {
        App classUnderTest = new App();
        assertNotNull(classUnderTest);
    }

    /*
     * Small semi-integration test of the RPC server that checks the session system
     * and two RPCs.
     * The client integration tests serve as a more comprehensive end-to-end test!
     */
    @Test
    void grpcServerWorks() throws Exception {
        Configuration config = new Configuration("../config.example.json");
        config.databaseFile = null;
        config.introductionHostname = null;
        Thread t = new Thread(new Runnable() {
            public void run() {
                try {
                    App.startServer(config);
                } catch (IOException ex) {
                    System.err.println("Unhandled I/O failure!");
                    System.err.println(ex.getMessage());
                    for (StackTraceElement ste : ex.getStackTrace()) {
                        System.err.println(ste + "\n");
                    }
                }
            }
        });

        t.start();

        ManagedChannel channel = ManagedChannelBuilder.forAddress("localhost", PORT).usePlaintext().build();
        ChatServiceBlockingStub stub = ChatServiceGrpc.newBlockingStub(channel);

        // create an account
        LoginCreateResponse createResponse = stub.createAccount(
                LoginCreateRequest.newBuilder().setUsername("june").setPasswordHash("1".repeat(29)).build());
        assertTrue(createResponse.getSuccess());
        assertNotNull(createResponse.getSessionKey());

        // list accounts
        ListAccountsResponse list = stub.listAccounts(ListAccountsRequest.newBuilder()
                .setSessionKey(createResponse.getSessionKey()).setMaximumNumber(1).build());
        assertEquals("june", list.getAccounts(0).getUsername());
        assertEquals("1-1", list.getAccounts(0).getId());

        // check that replication service is up
        ManagedChannel channel2 = ManagedChannelBuilder.forAddress("localhost", 55556).usePlaintext().build();
        ReplicationServiceBlockingStub replicationStub = ReplicationServiceGrpc.newBlockingStub(channel2);

        // should respond with "needs resync" since it won't know this replica ID
        RelayResponse response = replicationStub
                .relay(LogMessage.newBuilder().setOriginatingReplicaId("steve").build());
        assertEquals(true, response.getNeedsResync());

        t.interrupt();
    }
}
